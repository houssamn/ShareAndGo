role SYSTEM {
    //System Has Full Access on Everything For Now ...
    Person {
        fullAccess
    }

    Location {
        fullAccess
    }

    Zone {
        fullAccess
    }

    Trip {
        fullAccess
    }

    Complaint {
        fullAccess
    }

}

role USER {
    Person {
        read (firstName), read (lastName), read (username)
            
        read (livingZone), read (myRole) , read(asPassenger), read(asDriver), read(isBanned) constrainedBy [ caller = self ]

        update (firstName), update (lastName), update (password),
        update (livingZone) constrainedBy [ caller = self ]

        add (asPassenger) constrainedBy [ caller = self and
            not self.asPassenger->includes(target) and 
            not target.childLocations->any(v1| v1.zones->includes(caller.livingZone))->asSet()->isEmpty() 
        ]

        add (complaintFrom) constrainedBy [ target.complaintOwner = caller and not
            (caller.asPassenger->intersection(target.complaintTarget.asPassenger->
            union(target.complaintTarget.asDriver))->union(caller.asDriver->
            intersection(target.complaintTarget.asPassenger)))->asSet()->isEmpty() ]
    }
    
    Zone {
        read
    }

    Location {
        read
    }
    
    Trip {
        //read constrainedBy [ not(self.childLocations->any(v1| v1.zones->includes(caller.livingZone))->asSet()->isEmpty())]
        //TODO: Fix Later ... 
        read

        add (passengers) constrainedBy [ target = caller and not self.passengers->includes(target) 
        and self.childLocations->any(v1| not v1.zones->includes(caller.livingZone))->asSet()->isEmpty()]
    }

    Complaint {
        update (isCreated)

        update (complaintOwner) constrainedBy [ value = caller and 
            not self.isCreated
        ]

        update (complaintTarget) constrainedBy [
            self.complaintOwner = caller and
            not self.isCreated and 
            not value.asPassenger->intersection(caller.asPassenger->union(caller.asDriver))->
            union(value.asDriver->intersection(caller.asPassenger))->asSet()->isEmpty()
        ]

        update (text) constrainedBy [
            not self.isCreated and
            self.complaintOwner = caller
        ]
 
        update (associatedTrip) constrainedBy [not self.isCreated and self.complaintOwner = caller]

        create 

        delete constrainedBy [self.complaintOwner = caller and not self.isCreated]
    }
}


role PREMIUM_USER { 
    Person {
        read (firstName), read (lastName), read (username)
            
        read (livingZone), read(myRole), read(asPassenger), read(asDriver), read(isBanned) constrainedBy [ caller = self ]

        update (firstName), update (lastName), update (password),
        update (livingZone) constrainedBy [ caller = self ]

        add (asPassenger) constrainedBy [ caller = self and
            not self.asPassenger->includes(target) and 
            not target.childLocations->any(v1| v1.zones->includes(caller.livingZone))->asSet()->isEmpty() 
        ]

        add (complaintFrom) constrainedBy [ target.complaintOwner = caller and not
            (caller.asPassenger->intersection(target.complaintTarget.asPassenger->
            union(target.complaintTarget.asDriver))->union(caller.asDriver->
            intersection(target.complaintTarget.asPassenger)))->asSet()->isEmpty() ]
    
        add(asDriver) constrainedBy [ target.driver = caller ]

    }
    
    Zone {
        read
    }

    Location {
        read
    }
    
    Trip {
        //read constrainedBy [ not self.childLocations->any(v1| v1.zones->includes(caller.livingZone))->asSet()->isEmpty() 
        //                   or not self.childLocations->any(v2|v2.zones->any(zn|not (zn.locations->intersection(caller.livingZone.locations)->asSet()->isEmpty()))->asSet()->isEmpty())->asSet()->isEmpty()     ]

        //TODO: Change Read Constraint
        read

        add (passengers) constrainedBy [ target = caller and not self.passengers->includes(target) 
        and not self.childLocations->any(k|k.zones->includes(caller.livingZone))->asSet()->isEmpty() ]

        create 

        add(childLocations) constrainedBy [not(self.isCreated) and (self.driver = caller)  
                                and not(self.childLocations->includes(target)) 
                                and (target.zones->includes(caller.livingZone) 
                                or caller.asPassenger.childLocations->includes(target) ) ]  



        remove(childLocations) constrainedBy [not(self.isCreated) and self.driver = caller]

        update(driver) constrainedBy [not(self.isCreated) and value = caller ]
        
        update(price) constrainedBy [not(self.isCreated) and self.driver = caller ]

        update(isCreated) 

        update(startDate) constrainedBy [not(self.isCreated) and self.driver = caller]

        delete constrainedBy [not(self.isCreated) and self.driver = caller]

    }

    Complaint {
        update (complaintOwner) constrainedBy [ value = caller and 
            not self.isCreated
        ]

        update (complaintTarget) constrainedBy [
            self.complaintOwner = caller and
            not self.isCreated and 
            not value.asPassenger->intersection(caller.asPassenger->union(caller.asDriver))->union(value.asDriver->intersection(caller.asPassenger))->asSet()->isEmpty()
        ]

        update (text) constrainedBy [
            not self.isCreated and
            self.complaintOwner = caller
        ]

        update (isCreated)

        update (associatedTrip) constrainedBy [not self.isCreated and self.complaintOwner = caller]

        create 


        delete constrainedBy [self.complaintOwner = caller and not self.isCreated]
        //add himself as driver , update startDate, add(childLocations) under constraint, update price, update created[add to data model]
    }
}


role ADMIN {
    Person {
        read (complaintAbout)
    }

    Location {
        create

        read 

        update(name), update(x), update(y)

        //add the zone only if the location is not already in that zone
        add(zones) constrainedBy [ self.zones->excludes(target) ]
    }

    Zone {
        //TODO is an admin allowed to change a person's living zone?
        create

        read 
        
        update (zname)

        //add the location only if it is not already in the zone
        add(locations) constrainedBy [ self.locations->excludes(target) ]
    }

    Trip {
        read
    }
}